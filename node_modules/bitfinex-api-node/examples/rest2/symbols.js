'use strict'

process.env.DEBUG = 'bfx:examples:*'

const debug = require('debug')('bfx:examples:rest2_symbols')
const path = require('path')
const bfx = require('../bfx')
const rest = bfx.rest(2)
var bus = require('../../../../util/eventBus') // TODO: Fix paths

var e = 'ETH', b = 'BTC', u = 'USD', r = 'EUR', g = 'GBP', j = 'JPY';
var symbolarr = [e,b,u,r,g,j];

var symbol_array = [];
// Main pairs
var MAIN_pairs = [] // ? Combination of symbolarr elements
// Base pairs
var ETH_Pairs = [],
    BTC_Pairs = [],
    USD_Pairs = [],
    EUR_Pairs = [],
    GBP_Pairs = [],
    JPY_Pairs = [];

// Combined arrays
var ETHBTC_pairs = [],
    USDBTC_pairs = [],
    USDETH_pairs = [],
    EURBTC_pairs = [],
    EURETH_pairs = [],
    GBPBTC_pairs = [],
    GBPETH_pairs = [],
    JPYBTC_pairs = [],
    JPYETH_pairs = [];

// Overall array    
var overall = [];
var key, value, result;

function makeMainpairs () {
  return new Promise ((resolve, reject) => {
    let eth = symbolarr[0], btc = symbolarr[1];
    for(var i = 2; i < symbolarr.length; i++) {
      let val1 = 't' + String(eth + symbolarr[i]).toUpperCase();
      let val2 = 't' + String(btc + symbolarr[i]).toUpperCase(); 
      MAIN_pairs.push(val1);
      MAIN_pairs.push(val2);
    }
    debug('Mainpair array created')
    resolve();
  })
}

function makeArray (sub){
  var array_s = symbol_array[0]
  array_s.forEach(val => {
    if(val.substring(4) == sub){
      switch(sub) {
        case e: ETH_Pairs.push(val); break;
        case b: BTC_Pairs.push(val); break;
        case u: USD_Pairs.push(val); break;
        case r: EUR_Pairs.push(val); break;
        case g: GBP_Pairs.push(val); break;
        case j: JPY_Pairs.push(val); break;
      }
      debug('Added',val, 'to', sub, 'array')
    }
  })
  debug('Done', sub)
}

function compareArray (a1, a2, finalarr){
  return new Promise((resolve, reject) => {
    a1.forEach(val =>{
      a2.forEach(val2 =>{ 
        var alt = val2.substring(0,4)
        if(val.includes(alt)){
          finalarr.push(val)
          finalarr.push(val2)
          debug('Pushed %s and %s', val, val2)
        }
      })
    })
    resolve();
  })
}

debug('fetching symbol list...')

rest.symbols().then(symbols => {
  symbol_array.push(symbols.map(s => `t${s.toUpperCase()}`))
  debug('available symbols are: %s', symbol_array)
  for(var i = 0; i<=symbolarr.length; i++) {
    makeArray(symbolarr[i]);
  }
  // TODO: refactor this block
  makeMainpairs()
  .then(compareArray(ETH_Pairs, BTC_Pairs, ETHBTC_pairs)
  .then(compareArray(USD_Pairs, BTC_Pairs, USDBTC_pairs))
  .then(compareArray(USD_Pairs, ETH_Pairs, USDETH_pairs))
  .then(compareArray(GBP_Pairs, BTC_Pairs, GBPBTC_pairs))
  .then(compareArray(GBP_Pairs, ETH_Pairs, GBPETH_pairs))
  .then(compareArray(EUR_Pairs, BTC_Pairs, EURBTC_pairs))
  .then(compareArray(EUR_Pairs, ETH_Pairs, EURETH_pairs)))
  .then(() => {
    const symbolObject = {
      symbol_array: symbol_array,
      mainpairs: MAIN_pairs,
      ethpairs: ETH_Pairs,
      btcpairs: BTC_Pairs,
      usdpairs: USD_Pairs,
      eurpairs: EUR_Pairs,
      
      markets: {
        tETHBTC: ETHBTC_pairs,
        tBTCUSD: USDBTC_pairs,
        tETHUSD: USDETH_pairs,
        tBTCEUR: EURBTC_pairs,
        tETHEUR: EURETH_pairs,
        tBTCJPY: JPYBTC_pairs,
        tETHJPY: JPYETH_pairs,
        tBTCGBP: GBPBTC_pairs,
        tETHGBP: GBPETH_pairs
      }
      
    }
    module.exports = symbolObject;
    bus.emit('fetched-symbols', symbolObject)
  })
  
  
}).catch(err => {
  debug('error: %s', err)
})